#!/usr/bin/env python

import socket
import sys
import time
import os
import signal
import six

# global variables
seq_number = 0
send_count = 0
receive_count = 0
min_time = 999999999
max_time = 0.0
total_time = 0.0

MAX_SLEEP = 1000

# Setting the default timer
if sys.platform.startswith("win32"):
    default_timer = time.clock
else:
    default_timer = time.time

# ICMP Parameters
ICMP_ECHO_REPLY = 0 # icmp echo reply
ICMP_ECHO = 8 # icmp echo request
ICMP_MAX_RECV = 2048 # max in buffer

class Response(object):
    def __init__(self):
        self.max_rtt = None
        self.min_rtt = None
        self.avg_rtt = None
        self.packet_loss = None
        self.ret_code = None
        self.output = []
        self.packet_size = None
        self.timeout = None
        self.destination = None
        self.destination_ip = None

def print_unknown_host(destination, err):
    print "Unknown host: %s (%s)" % (destiantion, err.args[1])

    raise Exception("unknown host")

def is_valid_ip_address(dest):
    parts = dest.split(".")
    
    if not len(parts) == 4:
        return False
    
    for part in parts:
        try:
            num = int(part)
        except ValueError:
            return False
        if num < 0 or num > 255:
            return False

    return True

def get_ip(dest):
    if is_valid_ip_address(dest):
        return dest
    else:
        return socket.gethostbyname(dest)

def signal_handler(signum, frame):
    # hanling print_exit via signals
    print_exit()

    print "\nTerminated with signal %d\n" % (signum)
    sys.exit(0)

def setup_signal_handler():
    # for handling Ctrl + C
    signal.signal(signal.SIGINT, signal_handler)

    if hasattr(signal, "SIGBREAK"):
        # for handling Ctrl-Break e.g. in Windows
        signal.signal(signal.SIGBREAK, signal_handler)

def print_success(destination, delay, ip, packet_size, ip_header, icmp_header):
    if ip == destination:
        from_info = ip
    else:
        from_info = "%s (%s)" % (destination, ip)

    print "%d bytes from %s: icmp_seq=%d ttl=%d time=%.1f ms" % (packet_size, from_info, icmp_header["seq_number"], ip_header["ttl"], delay)

def print_failed():
    print "Request timed out.."

def do(destination, timeout):
    global send_count
    global receive_count
    global total_time
    global max_time
    global min_time

    # Send one ICMP ECHO_REQUEST and receive the response until timeout
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.getprotobyname("icmp"))
    except socket.error as e:
        if e.errno == 1:
            # Permission Not Granted Error
            etype, evalue, etb = sys.exc_info()
            evalue = etype(
                    "%s - Note that ICMP messages can only be sent from processes running as root" % evalue
                    )
            six.reraise(etype, evalue, etb)
        raise # raise the original error

    send_time = send_one_ping(sock)
    if send_time == None:
        return
    send_count += 1

    receive_time, packet_size, ip, ip_header, icmp_header = receive_one_ping(sock)
    # Closing the connection
    sock.close()

    if receive_time:
        receive_count += 1
        delay = (receive_time - send_time) * 1000.0
        total_time += delay
        if min_time > delay:
            min_time = delay
        if max_time < delay:
            max_time = delay

        print_success(destination, delay, ip, packet_size, ip_header, icmp_header)
        return delay
    else:
        print_failed()

def run(destination, count, timeout, deadline = None):
    # Send and Receive pings in a loop until count or deadline is reached
    global seq_number

    setup_signal_handler()

    while True:
        delay = do(destination, timeout)
        seq_number += 1

        if count and seq_num >= count:
            break
        if deadline and total_time >= deadline:
            break
        
        if delay == None:
            delay = 0

        # Pause for (MAX_SLEEP - delay) time
        if (MAX_SLEEP > delay):
            time.sleep((MAX_SLEEP -delay) / 1000.0)
        
        print_exit()

def ping(hostname, timeout=1000, count=3, packet_size=55,  *args, **kwargs):
    destination = hostname
    own_id = os.getpid() & 0xFFFF

    try:
        dest_ip = get_ip(destination)
    except socket.gaierror as err:
        print_unknown_host(destination, err)

    print "Pinging %s (%s) with %d bytes of data..." % (destination, dest_ip, packet_size)

    return run(destination, count, timeout)


target = raw_input("Enter the target name/address to ping: ")
ping(target)
