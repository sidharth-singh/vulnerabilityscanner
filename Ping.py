#!/usr/bin/env python

"""
Use this script as a superuser
"""

import socket
import select
import sys
import time
import os
import signal # Module of signal(interrupt) handling
import six 
import struct # for converting values to bytes

# global variables
seq_number = 0
send_count = 0
receive_count = 0
min_time = sys.maxint
max_time = 0.0
total_time = 0.0

MAX_SLEEP = 1000

# Setting the default timer
if sys.platform.startswith("win32"):
    default_timer = time.clock
else:
    default_timer = time.time

# ICMP Parameters
ICMP_ECHO_REPLY = 0 # icmp echo reply
ICMP_ECHO = 8 # icmp echo request
ICMP_MAX_RECV = 2048 # max in buffer

def print_unknown_host(target, err):
    print "Unknown host: %s (%s)" % (target, err.args[1])

    raise Exception("unknown host")

def is_valid_ip_address(target):
    parts = target.split(".")
    
    if not len(parts) == 4:
        return False
    
    for part in parts:
        try:
            num = int(part)
        except ValueError:
            return False
        if num < 0 or num > 255:
            return False

    return True

def get_ip(target):
    if is_valid_ip_address(target):
        return target
    else:
        return socket.gethostbyname(target)

def signal_handler(signum, frame):
    print "\nTerminated with signal %d\n" % (signum)
    sys.exit(0)

def setup_signal_handler():
    # for handling Ctrl + C
    signal.signal(signal.SIGINT, signal_handler)

    if hasattr(signal, "SIGBREAK"):
        # for handling Ctrl-Break e.g. in Windows
        signal.signal(signal.SIGBREAK, signal_handler)

def print_success(target, delay, ip, packet_size, ip_header, icmp_header):
    if ip == target:
        from_info = ip
    else:
        from_info = "%s (%s)" % (target, ip)

    print "%d bytes from %s: icmp_seq=%d ttl=%d time=%.1f ms" % (packet_size, from_info, icmp_header["seq_number"], ip_header["ttl"], delay)

def print_failed():
    print "Request timed out.."

def calculate_checksum(data_string):
    evenLength = (int(len(data_string) / 2)) * 2
    count = 0
    total_sum = 0

    # handling bytes in pairs
    loByte = 0
    hiByte = 0
    while count < evenLength:
        if(sys.byteorder == "little"):
            loByte = data_string[count]
            hiByte = data_string[count + 1]
        else:
            loByte = data_string[count + 1]
            hiByte = data_string[count]
        # ord returns the unicode value of char
        # example ord('a') = 97
        loByte = ord(loByte)
        hiByte = ord(hiByte)
        total_sum = total_sum + ((hiByte * 256) + loByte)
        count += 2

    # handle last byte (if there)
    if evenLength < len(data_string): # checking for odd length
        loByte = data_string[len(data_string) - 1]
        loByte = ord(loByte)
        total_sum += loByte

    total_sum &= 0xffffffff  # truncate to 32 bits

    total_sum = (total_sum >> 16) + (total_sum & 0xffff)  # add high 16 bits to low 16 bits
    total_sum += (total_sum >> 16)  # add carry from above
    answer = ~total_sum & 0xffff  # invert and truncate 16 bits
    # socket.htons  convert from host(little-endian) to network(big-endian) byte order
    answer = socket.htons(answer)

    return answer

"""
ICMP Echo / Echo Reply Message header info

      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Type      |     Code      |          Checksum             |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Identifier          |        Sequence Number        |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |     Data ...
      +-+-+-+-+-

"""

def send_one_ping(target, sock, packet_size, own_id):
    # send one Icmp Echo Request
    # Header is type (8), code (8), checksum (16), identifier (16), sequence (16)
    checksum = 0
    global seq_number
    #print seq_number
    #print own_id

    # Making a dummy header with 0 checksum by packing it with struct
    """
    Struct format:
        ! - network-byte order(usually big-endian)
        B - unsigned char
        H - unsigned short
    """
    header = struct.pack("!BBHHH", ICMP_ECHO, 0, checksum, own_id, seq_number)
    #print "dbg>>>5 " + str(header)

    pad_bytes = []
    start_value = 0x42
    for i in range(start_value, (start_value + packet_size)):
        pad_bytes += [(i & 0xff)] # keep the chars in range 0-255
    data = bytes(pad_bytes)  # convert data into sequence of bytes

    # calculate checksum on data and dummy header
    checksum = calculate_checksum(header + data)
    #print "dbg>>>4 " + str(checksum)

    # making the header again with correct checksum
    header = struct.pack("!BBHHH", ICMP_ECHO, 0, checksum, own_id, seq_number)
    
    # making the packet
    packet = header + data

    send_time = default_timer()

    try:
        #print sock
        #print target
        # sendto is used as socket is not connected
        sock.sendto(packet, (target, 1)) # port 1 is just for fun as ICMP doesn't need a port to connect to
    except socket.error as err:
        print "Error in socket -_- (%s)" % (err.args[1])
        sock.close()
        return
    
    return send_time

# function to unpack the raw header information and converting it to a dictionary
def header2dict(names, struct_format, data):
    unpacked_data = struct.unpack(struct_format, data)
    return dict(zip(names, unpacked_data))

def receive_one_ping(sock, timeout, own_id):
    # receiving the echo reply from the socket
    wait_timeout = timeout / 1000.0
    #print wait_timeout
    # loop until packet arrives or timeout occurs
    while True:
        select_start_time = default_timer()
        # waiting over our current socket object
        """
        select takes as input three lists and timeout:
        [objects ready for reading input], [objects ready for writing output], [objects ready for exceptional conditions]
        and returns the corresponding ready object lists from those lists after waiting
        """
        
        #print "dbg>>>" + str(sock)
        inputready, outputready, exceptready = select.select([sock], [], [], wait_timeout)
        select_duration = (default_timer() - select_start_time)
        #print "dbg>>>3 " + str(inputready)
        
        if inputready == []:
            return None, 0, 0, 0, 0

        packet_data, address = sock.recvfrom(ICMP_MAX_RECV)

        icmp_header = header2dict(names=["type", "code", "checksum", "packet_id", "seq_number"], struct_format="!BBHHH", data=packet_data[20:28])

        receive_time = default_timer()
        
        if icmp_header["packet_id"] == own_id: # our packet
            # struct format I is for unsigned int
            ip_header = header2dict(names=["version", "type", "length", "id", "flags", "ttl", "protocol", "checksum", "src_ip", "dest_ip"], struct_format="!BBHHHBBHII", data=packet_data[:20])
            packet_size = len(packet_data) - 28
            # socket.inet_ntoa for converting binary ip to dotted decimal notation
            ip = socket.inet_ntoa(struct.pack("!I", ip_header["src_ip"]))
            return receive_time, packet_size, ip, ip_header, icmp_header

        wait_timeout = wait_timeout - select_duration
        if wait_timeout <= 0:
            return None, 0, 0, 0, 0


def do(target, packet_size, timeout, own_id):
    global send_count
    global receive_count
    global total_time
    global max_time
    global min_time

    # Send one ICMP ECHO_REQUEST and receive the response until timeout
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.getprotobyname("icmp"))
    except socket.error as e:
        if e.errno == 1:
            # Permission Not Granted Error
            etype, evalue, etb = sys.exc_info()
            evalue = etype(
                    "%s - Note that ICMP messages can only be sent from processes running as root" % evalue
                    )
            six.reraise(etype, evalue, etb) # reraising the exception with different traceback
        raise # raise the original error

    send_time = send_one_ping(target, sock, packet_size, own_id)
    if send_time == None:
        return
    send_count += 1

    receive_time, packet_size, ip, ip_header, icmp_header = receive_one_ping(sock, timeout, own_id)
    # Closing the connection
    sock.close()
    
    #print "dbg>>>1 " + str(send_time)
    #print "dbg>>>2 " + str(receive_time)

    if receive_time:
        receive_count += 1
        delay = (receive_time - send_time) * 1000.0
        total_time += delay
        if min_time > delay:
            min_time = delay
        if max_time < delay:
            max_time = delay

        print_success(target, delay, ip, packet_size, ip_header, icmp_header)
        return delay
    else:
        print_failed()

# just the final results
def finishing_up(target):
    global send_count
    global receive_count

    lost_count = send_count - receive_count
    lost_rate = (float(lost_count) / send_count) * 100

    print "\nPacket loss is %0.1f%%" % (lost_rate)

    if receive_count > 0:
        print "%s is alive and reachable" % (target)

def run(target, count, packet_size, timeout, own_id, deadline = None):
    # Send and Receive pings in a loop until count or deadline is reached
    global seq_number

    setup_signal_handler()

    while True:
        delay = do(target, packet_size, timeout, own_id)
        seq_number += 1

        if count and seq_number >= count:
            break
        if deadline and total_time >= deadline:
            break
        
        if delay == None:
            delay = 0

        # Pause for (MAX_SLEEP - delay) time
        if (MAX_SLEEP > delay):
            time.sleep((MAX_SLEEP - delay) / 1000.0)
        
    finishing_up(target)

def ping(hostname, timeout=1000, count=3, packet_size=55):
    target = hostname
    own_id = os.getpid() & 0xFFFF

    try:
        dest_ip = get_ip(target)
        #print dest_ip
    except socket.gaierror as err:
        print_unknown_host(target, err)

    print "\nPinging %s (%s) with %d bytes of data..." % (target, dest_ip, packet_size)
    return run(target, count, packet_size, timeout, own_id)


target = raw_input("Enter the target name/address to ping: ")
ping(target)
